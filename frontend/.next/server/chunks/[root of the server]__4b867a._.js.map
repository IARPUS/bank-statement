{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/roychoi/Desktop/projects/bank-analysis/frontend/app/api/files/analyze/openAI/summary/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\n/**\n * POST /api/process-tesseract\n *\n * Expects JSON body:\n * {\n *   \"text\": \"Extracted text from Tesseract\"\n * }\n */\nexport async function POST(req) {\n  try {\n    // Parse the request body\n    const body = await req.json();\n\n    if (!body.text) {\n      return NextResponse.json(\n        { message: \"Missing 'text' in request body.\" },\n        { status: 400 }\n      );\n    }\n\n    // OpenAI API request\n    const openAIResponse = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n      method: \"POST\",\n      headers: {\n        \"Authorization\": `Bearer ${process.env.OPENAI_API_KEY}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"user\",\n            content: `Given the following data, please categorize the transactions (make assumptions if you need to) and return in the following JSON format (this is not inclusive of all types of categories, add more if needed):\n            ${body.text}\n{\n  \"categories\": {\n    \"Groceries\": {\n      \"transactions\": [\n        {\n          \"date\": \"\",\n          \"description\": \"\",\n          \"amount\": \"\",\n          \"paymentMethod\": \"\"\n        },\n        {\n          \"date\": \"\",\n          \"description\": \"\",\n          \"amount\": \"\",\n          \"paymentMethod\": \"\"\n        }\n      ],\n      \"total\": \"\"\n    },\n    \"Entertainment\": {\n      \"transactions\": [\n        {\n          \"date\": \"\",\n          \"description\": \"\",\n          \"amount\": \"\",\n          \"paymentMethod\": \"\"\n        },\n        {\n          \"date\": \"\",\n          \"description\": \"\",\n          \"amount\": \"\",\n          \"paymentMethod\": \"\"\n        }\n      ],\n      \"total\": \"\"\n    }\n  },\n  \"summary\": {\n    \"totalSpending\": \"\",\n    \"highestCategory\": \"\",\n    \"lowestCategory\": \"\"\n  }\n}\n`,\n          },\n        ],\n        temperature: 0.7,\n      }),\n    });\n\n    // Handle errors from OpenAI API\n    if (!openAIResponse.ok) {\n      const errorText = await openAIResponse.text();\n      return NextResponse.json(\n        { message: \"Failed to process text with OpenAI.\", error: errorText },\n        { status: openAIResponse.status }\n      );\n    }\n\n    // Parse the OpenAI response\n    const data = await openAIResponse.json();\n    const responseText = data.choices[0].message.content.trim();\n\n    // Extract the JSON block\n    const jsonStartIndex = responseText.indexOf(\"{\");\n    const jsonEndIndex = responseText.lastIndexOf(\"}\");\n\n    if (jsonStartIndex === -1 || jsonEndIndex === -1) {\n      return NextResponse.json(\n        { message: \"Failed to extract JSON block from OpenAI response.\" },\n        { status: 500 }\n      );\n    }\n\n    const jsonString = responseText.substring(jsonStartIndex, jsonEndIndex + 1);\n\n    // Parse JSON block\n    let parsedJson;\n    try {\n      parsedJson = JSON.parse(jsonString);\n    } catch (error) {\n      return NextResponse.json(\n        { message: \"Failed to parse JSON from OpenAI response.\", error: error.message },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json(\n      { message: \"Text processed successfully.\", parsedData: parsedJson },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"Error in proxy route:\", error);\n    return NextResponse.json(\n      { message: \"Unexpected error occurred.\", error: error.message },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,SAAS;IACpB,KAAK;QACH,YAAY;IACd;AACF;AAUO,eAAe,KAAK,GAAG;IAC5B,IAAI;QACF,yBAAyB;QACzB,MAAM,OAAO,MAAM,IAAI,IAAI;QAE3B,IAAI,CAAC,KAAK,IAAI,EAAE;YACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAkC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,iBAAiB,MAAM,MAAM,8CAA8C;YAC/E,QAAQ;YACR,SAAS;gBACP,iBAAiB,CAAC,OAAO,EAAE,QAAQ,GAAG,CAAC,cAAc,EAAE;gBACvD,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,UAAU;oBACR;wBACE,MAAM;wBACN,SAAS,CAAC;YACV,EAAE,KAAK,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CxB,CAAC;oBACS;iBACD;gBACD,aAAa;YACf;QACF;QAEA,gCAAgC;QAChC,IAAI,CAAC,eAAe,EAAE,EAAE;YACtB,MAAM,YAAY,MAAM,eAAe,IAAI;YAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAuC,OAAO;YAAU,GACnE;gBAAE,QAAQ,eAAe,MAAM;YAAC;QAEpC;QAEA,4BAA4B;QAC5B,MAAM,OAAO,MAAM,eAAe,IAAI;QACtC,MAAM,eAAe,KAAK,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI;QAEzD,yBAAyB;QACzB,MAAM,iBAAiB,aAAa,OAAO,CAAC;QAC5C,MAAM,eAAe,aAAa,WAAW,CAAC;QAE9C,IAAI,mBAAmB,CAAC,KAAK,iBAAiB,CAAC,GAAG;YAChD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAqD,GAChE;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,aAAa,aAAa,SAAS,CAAC,gBAAgB,eAAe;QAEzE,mBAAmB;QACnB,IAAI;QACJ,IAAI;YACF,aAAa,KAAK,KAAK,CAAC;QAC1B,EAAE,OAAO,OAAO;YACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAA8C,OAAO,MAAM,OAAO;YAAC,GAC9E;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAgC,YAAY;QAAW,GAClE;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAA8B,OAAO,MAAM,OAAO;QAAC,GAC9D;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}